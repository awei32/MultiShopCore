# 微服务数据源配置示例
# 配合 Spring Cloud Gateway 负载均衡使用

# ==================== 用户服务配置 ====================
# msc-user/src/main/resources/application.yaml

spring:
  application:
    name: msc-user
  
  # 数据源配置（主从分离）
  datasource:
    # 主数据源（写操作）
    master:
      jdbc-url: jdbc:mysql://localhost:3306/user_service_db?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: user_service
      password: userdb123
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000
    
    # 从数据源（读操作）
    slave:
      jdbc-url: jdbc:mysql://localhost:3307/user_service_db?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: user_service
      password: userdb123
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000

  # 服务发现配置
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
        namespace: 
        group: DEFAULT_GROUP

server:
  port: 8081

---

# ==================== 订单服务配置 ====================
# msc-order/src/main/resources/application.yaml

spring:
  application:
    name: msc-order
  
  # 数据源配置（主从分离）
  datasource:
    # 主数据源（写操作）
    master:
      jdbc-url: jdbc:mysql://localhost:3316/order_service_db?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: order_service
      password: orderdb123
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000
    
    # 从数据源（读操作）
    slave:
      jdbc-url: jdbc:mysql://localhost:3317/order_service_db?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: order_service
      password: orderdb123
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000

  # 服务发现配置
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
        namespace: 
        group: DEFAULT_GROUP

server:
  port: 8082

---

# ==================== 商品服务配置 ====================
# msc-product/src/main/resources/application.yaml

spring:
  application:
    name: msc-product
  
  # 数据源配置（主从分离）
  datasource:
    # 主数据源（写操作）
    master:
      jdbc-url: jdbc:mysql://localhost:3326/product_service_db?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: product_service
      password: productdb123
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000
    
    # 从数据源（读操作）
    slave:
      jdbc-url: jdbc:mysql://localhost:3327/product_service_db?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: product_service
      password: productdb123
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000

  # 服务发现配置
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
        namespace: 
        group: DEFAULT_GROUP

server:
  port: 8083

---

# ==================== 数据源配置类示例 ====================
# Java配置类，用于配置主从数据源

# DataSourceConfig.java
@Configuration
@EnableTransactionManagement
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DataSource routingDataSource() {
        DynamicDataSource routingDataSource = new DynamicDataSource();
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put("master", masterDataSource());
        dataSourceMap.put("slave", slaveDataSource());
        routingDataSource.setTargetDataSources(dataSourceMap);
        routingDataSource.setDefaultTargetDataSource(masterDataSource());
        return routingDataSource;
    }

    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(routingDataSource());
        return sessionFactory.getObject();
    }
}

# 动态数据源类
public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}

# 数据源上下文
public class DataSourceContextHolder {
    private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();

    public static void setDataSourceType(String dataSourceType) {
        contextHolder.set(dataSourceType);
    }

    public static String getDataSourceType() {
        return contextHolder.get();
    }

    public static void clearDataSourceType() {
        contextHolder.remove();
    }
}

# 读写分离注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    String value() default "master";
}

# AOP切面，自动切换数据源
@Aspect
@Component
public class DataSourceAspect {

    @Around("@annotation(dataSource)")
    public Object around(ProceedingJoinPoint point, DataSource dataSource) throws Throwable {
        DataSourceContextHolder.setDataSourceType(dataSource.value());
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clearDataSourceType();
        }
    }
}

# 使用示例
@Service
public class UserService {

    @DataSource("master")  // 使用主库
    public void saveUser(User user) {
        // 写操作
    }

    @DataSource("slave")   // 使用从库
    public User findUser(Long id) {
        // 读操作
        return null;
    }
}