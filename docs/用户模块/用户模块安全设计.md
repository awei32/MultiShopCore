# 用户模块安全设计文档

## 一、安全设计概述

### 1.1 设计目标

- **数据安全**：保护用户敏感信息不被泄露或篡改
- **访问控制**：确保用户只能访问授权的资源和功能
- **身份认证**：可靠的用户身份验证机制
- **传输安全**：保证数据在传输过程中的安全性
- **存储安全**：敏感数据的安全存储和加密
- **审计追踪**：完整的安全事件记录和审计日志
- **防护机制**：抵御常见的网络攻击和安全威胁

### 1.2 安全原则

| 原则 | 说明 | 实施要点 |
|------|------|----------|
| 最小权限原则 | 用户只获得完成任务所需的最小权限 | 细粒度权限控制，定期权限审查 |
| 深度防御 | 多层安全防护机制 | 网络、应用、数据多层防护 |
| 零信任架构 | 不信任任何用户或设备 | 持续验证，动态授权 |
| 数据分类保护 | 根据数据敏感性分级保护 | 敏感数据加密，访问控制 |
| 安全开发生命周期 | 在开发全过程中考虑安全 | 安全编码，安全测试 |
| 持续监控 | 实时监控安全状态 | 日志分析，异常检测 |

### 1.3 威胁模型

#### 1.3.1 外部威胁

| 威胁类型 | 威胁描述 | 影响等级 | 防护措施 |
|----------|----------|----------|----------|
| SQL注入 | 恶意SQL代码注入 | 高 | 参数化查询，输入验证 |
| XSS攻击 | 跨站脚本攻击 | 高 | 输出编码，CSP策略 |
| CSRF攻击 | 跨站请求伪造 | 中 | CSRF Token，同源检查 |
| 暴力破解 | 密码暴力破解 | 中 | 账户锁定，验证码 |
| DDoS攻击 | 分布式拒绝服务 | 高 | 限流，CDN防护 |
| 数据泄露 | 敏感数据被窃取 | 高 | 数据加密，访问控制 |

#### 1.3.2 内部威胁

| 威胁类型 | 威胁描述 | 影响等级 | 防护措施 |
|----------|----------|----------|----------|
| 权限滥用 | 内部人员滥用权限 | 高 | 权限最小化，审计日志 |
| 数据泄露 | 内部人员泄露数据 | 高 | 数据脱敏，行为监控 |
| 系统误操作 | 误删除或误修改 | 中 | 操作确认，数据备份 |
| 配置错误 | 安全配置错误 | 中 | 配置检查，安全基线 |

## 二、身份认证安全

### 2.1 密码安全策略

#### 2.1.1 密码复杂度要求

```json
{
  "passwordPolicy": {
    "minLength": 8,
    "maxLength": 128,
    "requireUppercase": true,
    "requireLowercase": true,
    "requireNumbers": true,
    "requireSpecialChars": true,
    "forbiddenPatterns": [
      "123456",
      "password",
      "qwerty",
      "admin"
    ],
    "forbidPersonalInfo": true,
    "historyCheck": 5
  }
}
```

#### 2.1.2 密码存储安全

```java
// 密码加密配置
@Configuration
public class PasswordSecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        // 使用BCrypt算法，工作因子为12
        return new BCryptPasswordEncoder(12);
    }
    
    @Bean
    public PasswordValidator passwordValidator() {
        return new PasswordValidator(
            // 长度检查
            new LengthRule(8, 128),
            // 字符类型检查
            new CharacterRule(EnglishCharacterData.UpperCase, 1),
            new CharacterRule(EnglishCharacterData.LowerCase, 1),
            new CharacterRule(EnglishCharacterData.Digit, 1),
            new CharacterRule(EnglishCharacterData.Special, 1),
            // 禁止常见密码
            new IllegalSequenceRule(EnglishSequenceData.Alphabetical, 3, false),
            new IllegalSequenceRule(EnglishSequenceData.Numerical, 3, false),
            new IllegalSequenceRule(EnglishSequenceData.USQwerty, 3, false),
            // 禁止重复字符
            new RepeatCharacterRegexRule(3)
        );
    }
}
```

#### 2.1.3 密码重置安全

```java
// 密码重置服务
@Service
public class PasswordResetService {
    
    // 生成重置令牌
    public String generateResetToken(Long userId) {
        // 生成随机令牌
        String token = SecureRandomUtils.generateToken(32);
        
        // 设置过期时间（15分钟）
        LocalDateTime expireTime = LocalDateTime.now().plusMinutes(15);
        
        // 存储令牌信息
        PasswordResetToken resetToken = new PasswordResetToken();
        resetToken.setUserId(userId);
        resetToken.setToken(hashToken(token));
        resetToken.setExpireTime(expireTime);
        resetToken.setUsed(false);
        
        passwordResetTokenRepository.save(resetToken);
        
        return token;
    }
    
    // 验证重置令牌
    public boolean validateResetToken(String token, Long userId) {
        String hashedToken = hashToken(token);
        
        PasswordResetToken resetToken = passwordResetTokenRepository
            .findByTokenAndUserId(hashedToken, userId);
        
        if (resetToken == null || resetToken.isUsed()) {
            return false;
        }
        
        if (resetToken.getExpireTime().isBefore(LocalDateTime.now())) {
            return false;
        }
        
        return true;
    }
    
    private String hashToken(String token) {
        return DigestUtils.sha256Hex(token + SALT);
    }
}
```

### 2.2 多因素认证(MFA)

#### 2.2.1 TOTP认证

```java
// TOTP认证服务
@Service
public class TotpAuthService {
    
    private static final String ISSUER = "MultiShopCore";
    private static final int WINDOW_SIZE = 3;
    
    // 生成TOTP密钥
    public TotpSecret generateSecret(Long userId) {
        String secret = Base32.random();
        String qrCodeUrl = generateQrCodeUrl(userId, secret);
        
        TotpSecret totpSecret = new TotpSecret();
        totpSecret.setUserId(userId);
        totpSecret.setSecret(encryptSecret(secret));
        totpSecret.setQrCodeUrl(qrCodeUrl);
        totpSecret.setEnabled(false);
        
        return totpSecretRepository.save(totpSecret);
    }
    
    // 验证TOTP代码
    public boolean verifyTotp(Long userId, String code) {
        TotpSecret totpSecret = totpSecretRepository.findByUserId(userId);
        if (totpSecret == null || !totpSecret.isEnabled()) {
            return false;
        }
        
        String secret = decryptSecret(totpSecret.getSecret());
        TimeBasedOneTimePasswordGenerator totp = new TimeBasedOneTimePasswordGenerator();
        
        long currentTime = System.currentTimeMillis() / 30000;
        
        // 检查当前时间窗口及前后窗口
        for (int i = -WINDOW_SIZE; i <= WINDOW_SIZE; i++) {
            String expectedCode = totp.generateOneTimePassword(secret, currentTime + i);
            if (code.equals(expectedCode)) {
                return true;
            }
        }
        
        return false;
    }
    
    private String generateQrCodeUrl(Long userId, String secret) {
        return String.format(
            "otpauth://totp/%s:%s?secret=%s&issuer=%s",
            ISSUER, userId, secret, ISSUER
        );
    }
}
```

#### 2.2.2 短信验证码安全

```java
// 短信验证码服务
@Service
public class SmsCodeService {
    
    private static final int CODE_LENGTH = 6;
    private static final int EXPIRE_MINUTES = 5;
    private static final int MAX_ATTEMPTS = 3;
    private static final int SEND_INTERVAL_SECONDS = 60;
    
    // 发送验证码
    public void sendSmsCode(String phone, String scene) {
        // 检查发送频率限制
        checkSendFrequency(phone);
        
        // 生成验证码
        String code = generateSmsCode();
        
        // 存储验证码
        SmsCode smsCode = new SmsCode();
        smsCode.setPhone(phone);
        smsCode.setCode(hashCode(code));
        smsCode.setScene(scene);
        smsCode.setExpireTime(LocalDateTime.now().plusMinutes(EXPIRE_MINUTES));
        smsCode.setAttempts(0);
        smsCode.setUsed(false);
        
        smsCodeRepository.save(smsCode);
        
        // 发送短信
        smsService.sendCode(phone, code, scene);
        
        // 记录发送日志
        logSmsCodeSent(phone, scene);
    }
    
    // 验证短信验证码
    public boolean verifySmsCode(String phone, String code, String scene) {
        SmsCode smsCode = smsCodeRepository
            .findByPhoneAndSceneAndUsedFalse(phone, scene);
        
        if (smsCode == null) {
            return false;
        }
        
        // 检查过期时间
        if (smsCode.getExpireTime().isBefore(LocalDateTime.now())) {
            return false;
        }
        
        // 检查尝试次数
        if (smsCode.getAttempts() >= MAX_ATTEMPTS) {
            return false;
        }
        
        // 增加尝试次数
        smsCode.setAttempts(smsCode.getAttempts() + 1);
        smsCodeRepository.save(smsCode);
        
        // 验证代码
        if (hashCode(code).equals(smsCode.getCode())) {
            smsCode.setUsed(true);
            smsCodeRepository.save(smsCode);
            return true;
        }
        
        return false;
    }
    
    private void checkSendFrequency(String phone) {
        LocalDateTime lastSendTime = smsCodeRepository
            .findLastSendTime(phone);
        
        if (lastSendTime != null && 
            lastSendTime.plusSeconds(SEND_INTERVAL_SECONDS)
                .isAfter(LocalDateTime.now())) {
            throw new BusinessException("发送过于频繁，请稍后再试");
        }
    }
    
    private String generateSmsCode() {
        return String.format("%0" + CODE_LENGTH + "d", 
            new Random().nextInt((int) Math.pow(10, CODE_LENGTH)));
    }
    
    private String hashCode(String code) {
        return DigestUtils.sha256Hex(code + SMS_SALT);
    }
}
```

### 2.3 JWT Token安全

#### 2.3.1 Token生成与验证

```java
// JWT服务
@Service
public class JwtTokenService {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private int jwtExpiration;
    
    @Value("${jwt.refresh.expiration}")
    private int refreshExpiration;
    
    // 生成访问令牌
    public String generateAccessToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userDetails.getUserId());
        claims.put("username", userDetails.getUsername());
        claims.put("authorities", userDetails.getAuthorities());
        claims.put("tokenType", "access");
        
        return createToken(claims, userDetails.getUsername(), jwtExpiration);
    }
    
    // 生成刷新令牌
    public String generateRefreshToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userDetails.getUserId());
        claims.put("tokenType", "refresh");
        
        String refreshToken = createToken(claims, userDetails.getUsername(), refreshExpiration);
        
        // 存储刷新令牌
        storeRefreshToken(userDetails.getUserId(), refreshToken);
        
        return refreshToken;
    }
    
    // 验证令牌
    public boolean validateToken(String token, UserDetails userDetails) {
        try {
            final String username = getUsernameFromToken(token);
            return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
        } catch (Exception e) {
            return false;
        }
    }
    
    // 检查令牌是否在黑名单中
    public boolean isTokenBlacklisted(String token) {
        String jti = getJtiFromToken(token);
        return tokenBlacklistRepository.existsByJti(jti);
    }
    
    // 将令牌加入黑名单
    public void blacklistToken(String token) {
        String jti = getJtiFromToken(token);
        Date expiration = getExpirationDateFromToken(token);
        
        TokenBlacklist blacklist = new TokenBlacklist();
        blacklist.setJti(jti);
        blacklist.setExpiration(expiration);
        
        tokenBlacklistRepository.save(blacklist);
    }
    
    private String createToken(Map<String, Object> claims, String subject, int expiration) {
        String jti = UUID.randomUUID().toString();
        claims.put("jti", jti);
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
            .signWith(SignatureAlgorithm.HS512, jwtSecret)
            .compact();
    }
    
    private void storeRefreshToken(Long userId, String refreshToken) {
        String hashedToken = DigestUtils.sha256Hex(refreshToken);
        
        RefreshToken token = new RefreshToken();
        token.setUserId(userId);
        token.setToken(hashedToken);
        token.setExpireTime(LocalDateTime.now().plusSeconds(refreshExpiration));
        
        refreshTokenRepository.save(token);
    }
}
```

#### 2.3.2 Token安全配置

```yaml
# JWT配置
jwt:
  secret: ${JWT_SECRET:your-256-bit-secret-key-here}
  expiration: 7200  # 2小时
  refresh:
    expiration: 604800  # 7天
  
# Token安全配置
security:
  token:
    # 令牌黑名单清理间隔（小时）
    blacklist-cleanup-interval: 24
    # 最大并发会话数
    max-concurrent-sessions: 5
    # 会话超时时间（分钟）
    session-timeout: 30
    # 是否允许多设备登录
    allow-multiple-devices: true
```

### 2.4 会话管理安全

#### 2.4.1 会话控制

```java
// 会话管理服务
@Service
public class SessionManagementService {
    
    @Value("${security.token.max-concurrent-sessions}")
    private int maxConcurrentSessions;
    
    @Value("${security.token.allow-multiple-devices}")
    private boolean allowMultipleDevices;
    
    // 创建用户会话
    public UserSession createSession(Long userId, String deviceInfo, String ipAddress) {
        // 检查并发会话限制
        checkConcurrentSessions(userId);
        
        UserSession session = new UserSession();
        session.setUserId(userId);
        session.setSessionId(UUID.randomUUID().toString());
        session.setDeviceInfo(deviceInfo);
        session.setIpAddress(ipAddress);
        session.setLoginTime(LocalDateTime.now());
        session.setLastActiveTime(LocalDateTime.now());
        session.setActive(true);
        
        return userSessionRepository.save(session);
    }
    
    // 更新会话活跃时间
    public void updateSessionActivity(String sessionId) {
        UserSession session = userSessionRepository.findBySessionId(sessionId);
        if (session != null && session.isActive()) {
            session.setLastActiveTime(LocalDateTime.now());
            userSessionRepository.save(session);
        }
    }
    
    // 终止会话
    public void terminateSession(String sessionId) {
        UserSession session = userSessionRepository.findBySessionId(sessionId);
        if (session != null) {
            session.setActive(false);
            session.setLogoutTime(LocalDateTime.now());
            userSessionRepository.save(session);
        }
    }
    
    // 终止用户所有会话
    public void terminateAllUserSessions(Long userId) {
        List<UserSession> sessions = userSessionRepository
            .findByUserIdAndActiveTrue(userId);
        
        for (UserSession session : sessions) {
            session.setActive(false);
            session.setLogoutTime(LocalDateTime.now());
        }
        
        userSessionRepository.saveAll(sessions);
    }
    
    private void checkConcurrentSessions(Long userId) {
        List<UserSession> activeSessions = userSessionRepository
            .findByUserIdAndActiveTrue(userId);
        
        if (activeSessions.size() >= maxConcurrentSessions) {
            if (!allowMultipleDevices) {
                // 踢出最早的会话
                UserSession oldestSession = activeSessions.stream()
                    .min(Comparator.comparing(UserSession::getLoginTime))
                    .orElse(null);
                
                if (oldestSession != null) {
                    terminateSession(oldestSession.getSessionId());
                }
            } else {
                throw new BusinessException("超过最大并发会话数限制");
            }
        }
    }
}
```

## 三、数据安全保护

### 3.1 敏感数据加密

#### 3.1.1 数据分类与加密策略

| 数据类型 | 敏感级别 | 加密方式 | 密钥管理 |
|----------|----------|----------|----------|
| 密码 | 极高 | BCrypt哈希 | 不可逆 |
| 身份证号 | 高 | AES-256-GCM | HSM管理 |
| 手机号 | 高 | AES-256-GCM | HSM管理 |
| 邮箱 | 中 | AES-256-GCM | HSM管理 |
| 姓名 | 中 | AES-256-GCM | HSM管理 |
| 地址 | 中 | AES-256-GCM | HSM管理 |
| 用户名 | 低 | 明文 | 无 |
| 昵称 | 低 | 明文 | 无 |

#### 3.1.2 字段级加密实现

```java
// 数据加密服务
@Service
public class DataEncryptionService {
    
    @Autowired
    private KeyManagementService keyManagementService;
    
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;
    
    // 加密敏感数据
    public String encrypt(String plaintext, String keyId) {
        try {
            SecretKey key = keyManagementService.getKey(keyId);
            
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            
            // 生成随机IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            SecureRandom.getInstanceStrong().nextBytes(iv);
            
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, parameterSpec);
            
            byte[] ciphertext = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
            
            // 组合IV和密文
            byte[] encryptedData = new byte[iv.length + ciphertext.length];
            System.arraycopy(iv, 0, encryptedData, 0, iv.length);
            System.arraycopy(ciphertext, 0, encryptedData, iv.length, ciphertext.length);
            
            return Base64.getEncoder().encodeToString(encryptedData);
        } catch (Exception e) {
            throw new SecurityException("数据加密失败", e);
        }
    }
    
    // 解密敏感数据
    public String decrypt(String encryptedData, String keyId) {
        try {
            SecretKey key = keyManagementService.getKey(keyId);
            
            byte[] decodedData = Base64.getDecoder().decode(encryptedData);
            
            // 分离IV和密文
            byte[] iv = new byte[GCM_IV_LENGTH];
            byte[] ciphertext = new byte[decodedData.length - GCM_IV_LENGTH];
            
            System.arraycopy(decodedData, 0, iv, 0, iv.length);
            System.arraycopy(decodedData, iv.length, ciphertext, 0, ciphertext.length);
            
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, key, parameterSpec);
            
            byte[] plaintext = cipher.doFinal(ciphertext);
            
            return new String(plaintext, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new SecurityException("数据解密失败", e);
        }
    }
}

// JPA加密转换器
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, String> {
    
    @Autowired
    private DataEncryptionService encryptionService;
    
    private static final String KEY_ID = "user_data_key";
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) {
            return null;
        }
        return encryptionService.encrypt(attribute, KEY_ID);
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        return encryptionService.decrypt(dbData, KEY_ID);
    }
}

// 实体类使用加密
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    @Convert(converter = EncryptedStringConverter.class)
    private String phone;
    
    @Convert(converter = EncryptedStringConverter.class)
    private String email;
    
    @Convert(converter = EncryptedStringConverter.class)
    private String realName;
    
    @Convert(converter = EncryptedStringConverter.class)
    private String idCard;
    
    // getters and setters
}
```

#### 3.1.3 密钥管理

```java
// 密钥管理服务
@Service
public class KeyManagementService {
    
    @Value("${security.encryption.hsm.enabled:false}")
    private boolean hsmEnabled;
    
    @Autowired
    private HsmClient hsmClient;
    
    @Autowired
    private LocalKeyStore localKeyStore;
    
    // 获取加密密钥
    public SecretKey getKey(String keyId) {
        if (hsmEnabled) {
            return hsmClient.getKey(keyId);
        } else {
            return localKeyStore.getKey(keyId);
        }
    }
    
    // 生成新密钥
    public String generateKey(String keyId) {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(256);
            SecretKey key = keyGenerator.generateKey();
            
            if (hsmEnabled) {
                hsmClient.storeKey(keyId, key);
            } else {
                localKeyStore.storeKey(keyId, key);
            }
            
            return keyId;
        } catch (Exception e) {
            throw new SecurityException("密钥生成失败", e);
        }
    }
    
    // 轮换密钥
    public void rotateKey(String keyId) {
        String newKeyId = keyId + "_" + System.currentTimeMillis();
        generateKey(newKeyId);
        
        // 标记旧密钥为待删除
        markKeyForDeletion(keyId);
        
        // 更新密钥映射
        updateKeyMapping(keyId, newKeyId);
    }
}
```

### 3.2 数据脱敏

#### 3.2.1 脱敏规则配置

```java
// 数据脱敏配置
@Configuration
public class DataMaskingConfig {
    
    @Bean
    public DataMaskingProcessor dataMaskingProcessor() {
        DataMaskingProcessor processor = new DataMaskingProcessor();
        
        // 手机号脱敏：138****8000
        processor.addRule("phone", new PhoneMaskingRule());
        
        // 邮箱脱敏：t***@example.com
        processor.addRule("email", new EmailMaskingRule());
        
        // 身份证脱敏：110101********1234
        processor.addRule("idCard", new IdCardMaskingRule());
        
        // 姓名脱敏：张*
        processor.addRule("name", new NameMaskingRule());
        
        // 地址脱敏：北京市朝阳区****
        processor.addRule("address", new AddressMaskingRule());
        
        return processor;
    }
}

// 手机号脱敏规则
public class PhoneMaskingRule implements MaskingRule {
    
    @Override
    public String mask(String value) {
        if (StringUtils.isEmpty(value) || value.length() < 11) {
            return value;
        }
        
        return value.substring(0, 3) + "****" + value.substring(7);
    }
}

// 邮箱脱敏规则
public class EmailMaskingRule implements MaskingRule {
    
    @Override
    public String mask(String value) {
        if (StringUtils.isEmpty(value) || !value.contains("@")) {
            return value;
        }
        
        String[] parts = value.split("@");
        String username = parts[0];
        String domain = parts[1];
        
        if (username.length() <= 1) {
            return value;
        }
        
        String maskedUsername = username.charAt(0) + "***";
        return maskedUsername + "@" + domain;
    }
}

// 脱敏注解
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataMasking {
    String rule();
}

// 脱敏切面
@Aspect
@Component
public class DataMaskingAspect {
    
    @Autowired
    private DataMaskingProcessor maskingProcessor;
    
    @Around("@annotation(org.springframework.web.bind.annotation.GetMapping)")
    public Object maskResponseData(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = joinPoint.proceed();
        
        if (result != null) {
            return maskingProcessor.process(result);
        }
        
        return result;
    }
}
```

### 3.3 数据备份与恢复

#### 3.3.1 备份策略

```yaml
# 数据备份配置
backup:
  strategy:
    # 全量备份
    full:
      enabled: true
      schedule: "0 0 2 * * ?" # 每天凌晨2点
      retention-days: 30
      encryption: true
      
    # 增量备份
    incremental:
      enabled: true
      schedule: "0 0 */6 * * ?" # 每6小时
      retention-days: 7
      encryption: true
      
    # 日志备份
    log:
      enabled: true
      schedule: "0 0 1 * * ?" # 每天凌晨1点
      retention-days: 90
      compression: true
      
  storage:
    type: "s3" # 存储类型：local, s3, oss
    bucket: "multishop-backup"
    region: "us-east-1"
    encryption-key: "${BACKUP_ENCRYPTION_KEY}"
    
  notification:
    enabled: true
    success-webhook: "${BACKUP_SUCCESS_WEBHOOK}"
    failure-webhook: "${BACKUP_FAILURE_WEBHOOK}"
```

#### 3.3.2 备份实现

```java
// 数据备份服务
@Service
public class DataBackupService {
    
    @Autowired
    private DatabaseBackupExecutor databaseBackupExecutor;
    
    @Autowired
    private FileBackupExecutor fileBackupExecutor;
    
    @Autowired
    private BackupEncryptionService encryptionService;
    
    @Autowired
    private BackupStorageService storageService;
    
    // 执行全量备份
    @Scheduled(cron = "${backup.strategy.full.schedule}")
    public void performFullBackup() {
        try {
            log.info("开始执行全量备份");
            
            BackupTask task = new BackupTask();
            task.setType(BackupType.FULL);
            task.setStartTime(LocalDateTime.now());
            task.setStatus(BackupStatus.RUNNING);
            
            backupTaskRepository.save(task);
            
            // 备份数据库
            String dbBackupFile = databaseBackupExecutor.createFullBackup();
            
            // 备份文件
            String fileBackupFile = fileBackupExecutor.createFullBackup();
            
            // 加密备份文件
            String encryptedDbFile = encryptionService.encrypt(dbBackupFile);
            String encryptedFileFile = encryptionService.encrypt(fileBackupFile);
            
            // 上传到存储
            String dbBackupUrl = storageService.upload(encryptedDbFile);
            String fileBackupUrl = storageService.upload(encryptedFileFile);
            
            // 更新任务状态
            task.setDbBackupUrl(dbBackupUrl);
            task.setFileBackupUrl(fileBackupUrl);
            task.setEndTime(LocalDateTime.now());
            task.setStatus(BackupStatus.SUCCESS);
            
            backupTaskRepository.save(task);
            
            // 清理本地文件
            cleanupLocalFiles(dbBackupFile, fileBackupFile, encryptedDbFile, encryptedFileFile);
            
            // 发送成功通知
            notificationService.sendBackupSuccessNotification(task);
            
            log.info("全量备份完成，任务ID: {}", task.getId());
            
        } catch (Exception e) {
            log.error("全量备份失败", e);
            notificationService.sendBackupFailureNotification(e);
        }
    }
    
    // 数据恢复
    public void restoreFromBackup(Long backupTaskId, RestoreOptions options) {
        try {
            BackupTask backupTask = backupTaskRepository.findById(backupTaskId)
                .orElseThrow(() -> new BusinessException("备份任务不存在"));
            
            if (backupTask.getStatus() != BackupStatus.SUCCESS) {
                throw new BusinessException("备份任务状态异常，无法恢复");
            }
            
            log.info("开始数据恢复，备份任务ID: {}", backupTaskId);
            
            // 下载备份文件
            String encryptedDbFile = storageService.download(backupTask.getDbBackupUrl());
            String encryptedFileFile = storageService.download(backupTask.getFileBackupUrl());
            
            // 解密备份文件
            String dbBackupFile = encryptionService.decrypt(encryptedDbFile);
            String fileBackupFile = encryptionService.decrypt(encryptedFileFile);
            
            // 恢复数据库
            if (options.isRestoreDatabase()) {
                databaseBackupExecutor.restore(dbBackupFile);
            }
            
            // 恢复文件
            if (options.isRestoreFiles()) {
                fileBackupExecutor.restore(fileBackupFile);
            }
            
            // 清理临时文件
            cleanupLocalFiles(encryptedDbFile, encryptedFileFile, dbBackupFile, fileBackupFile);
            
            log.info("数据恢复完成");
            
        } catch (Exception e) {
            log.error("数据恢复失败", e);
            throw new BusinessException("数据恢复失败: " + e.getMessage());
        }
    }
}
```

## 四、访问控制与权限管理

### 4.1 基于角色的访问控制(RBAC)

#### 4.1.1 权限模型设计

```sql
-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 角色表
CREATE TABLE roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_code VARCHAR(50) UNIQUE NOT NULL,
    role_name VARCHAR(100) NOT NULL,
    description TEXT,
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 权限表
CREATE TABLE permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    permission_code VARCHAR(100) UNIQUE NOT NULL,
    permission_name VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id VARCHAR(100),
    action VARCHAR(50) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户角色关联表
CREATE TABLE user_roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    granted_by BIGINT,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    UNIQUE KEY uk_user_role (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (role_id) REFERENCES roles(id)
);

-- 角色权限关联表
CREATE TABLE role_permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    granted_by BIGINT,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_role_permission (role_id, permission_id),
    FOREIGN KEY (role_id) REFERENCES roles(id),
    FOREIGN KEY (permission_id) REFERENCES permissions(id)
);

-- 用户权限关联表（直接授权）
CREATE TABLE user_permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    granted_by BIGINT,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    UNIQUE KEY uk_user_permission (user_id, permission_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (permission_id) REFERENCES permissions(id)
);
```

#### 4.1.2 权限验证实现

```java
// 权限验证服务
@Service
public class PermissionService {
    
    @Autowired
    private UserPermissionRepository userPermissionRepository;
    
    @Autowired
    private RolePermissionRepository rolePermissionRepository;
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    // 检查用户是否有指定权限
    public boolean hasPermission(Long userId, String permissionCode) {
        // 检查直接权限
        if (hasDirectPermission(userId, permissionCode)) {
            return true;
        }
        
        // 检查角色权限
        return hasRolePermission(userId, permissionCode);
    }
    
    // 检查用户是否有资源权限
    public boolean hasResourcePermission(Long userId, String resourceType, 
                                       String resourceId, String action) {
        String permissionCode = String.format("%s:%s:%s", resourceType, resourceId, action);
        return hasPermission(userId, permissionCode);
    }
    
    // 获取用户所有权限
    public Set<String> getUserPermissions(Long userId) {
        Set<String> permissions = new HashSet<>();
        
        // 获取直接权限
        List<String> directPermissions = userPermissionRepository
            .findPermissionCodesByUserId(userId);
        permissions.addAll(directPermissions);
        
        // 获取角色权限
        List<String> rolePermissions = rolePermissionRepository
            .findPermissionCodesByUserId(userId);
        permissions.addAll(rolePermissions);
        
        return permissions;
    }
    
    private boolean hasDirectPermission(Long userId, String permissionCode) {
        return userPermissionRepository
            .existsByUserIdAndPermissionCodeAndExpiresAtAfter(
                userId, permissionCode, LocalDateTime.now());
    }
    
    private boolean hasRolePermission(Long userId, String permissionCode) {
        List<Long> roleIds = userRoleRepository.findRoleIdsByUserId(userId);
        
        for (Long roleId : roleIds) {
            if (rolePermissionRepository
                .existsByRoleIdAndPermissionCode(roleId, permissionCode)) {
                return true;
            }
        }
        
        return false;
    }
}

// 权限注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String value();
    String resource() default "";
    String action() default "";
}

// 权限切面
@Aspect
@Component
public class PermissionAspect {
    
    @Autowired
    private PermissionService permissionService;
    
    @Around("@annotation(requirePermission)")
    public Object checkPermission(ProceedingJoinPoint joinPoint, 
                                RequirePermission requirePermission) throws Throwable {
        
        // 获取当前用户
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new AccessDeniedException("用户未认证");
        }
        
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        Long userId = userDetails.getUserId();
        
        // 检查权限
        boolean hasPermission;
        if (StringUtils.isNotEmpty(requirePermission.resource()) && 
            StringUtils.isNotEmpty(requirePermission.action())) {
            // 资源权限检查
            String resourceId = extractResourceId(joinPoint, requirePermission.resource());
            hasPermission = permissionService.hasResourcePermission(
                userId, requirePermission.resource(), resourceId, requirePermission.action());
        } else {
            // 功能权限检查
            hasPermission = permissionService.hasPermission(userId, requirePermission.value());
        }
        
        if (!hasPermission) {
            throw new AccessDeniedException("权限不足");
        }
        
        return joinPoint.proceed();
    }
    
    private String extractResourceId(ProceedingJoinPoint joinPoint, String resourceParam) {
        // 从方法参数中提取资源ID
        Object[] args = joinPoint.getArgs();
        String[] paramNames = getParameterNames(joinPoint);
        
        for (int i = 0; i < paramNames.length; i++) {
            if (resourceParam.equals(paramNames[i])) {
                return String.valueOf(args[i]);
            }
        }
        
        return null;
    }
}
```

### 4.2 数据权限控制

#### 4.2.1 行级安全策略

```java
// 数据权限过滤器
@Component
public class DataPermissionFilter {
    
    @Autowired
    private PermissionService permissionService;
    
    // 添加数据权限条件
    public void addDataPermissionCondition(Long userId, CriteriaBuilder cb, 
                                         CriteriaQuery<?> query, Root<?> root) {
        
        // 获取用户数据权限范围
        DataPermissionScope scope = getDataPermissionScope(userId);
        
        List<Predicate> predicates = new ArrayList<>();
        
        switch (scope.getType()) {
            case ALL:
                // 可以访问所有数据
                break;
                
            case DEPARTMENT:
                // 只能访问本部门数据
                predicates.add(cb.equal(root.get("departmentId"), scope.getDepartmentId()));
                break;
                
            case SELF:
                // 只能访问自己的数据
                predicates.add(cb.equal(root.get("userId"), userId));
                break;
                
            case CUSTOM:
                // 自定义权限范围
                addCustomPermissionCondition(userId, cb, query, root, predicates);
                break;
        }
        
        if (!predicates.isEmpty()) {
            query.where(cb.and(predicates.toArray(new Predicate[0])));
        }
    }
    
    private DataPermissionScope getDataPermissionScope(Long userId) {
        // 根据用户角色和权限确定数据权限范围
        Set<String> permissions = permissionService.getUserPermissions(userId);
        
        if (permissions.contains("data:all")) {
            return new DataPermissionScope(DataPermissionType.ALL);
        } else if (permissions.contains("data:department")) {
            Long departmentId = getUserDepartmentId(userId);
            return new DataPermissionScope(DataPermissionType.DEPARTMENT, departmentId);
        } else {
            return new DataPermissionScope(DataPermissionType.SELF);
        }
    }
}

// 数据权限注解
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataPermission {
    String entity();
    String[] conditions() default {};
}

// 数据权限切面
@Aspect
@Component
public class DataPermissionAspect {
    
    @Autowired
    private DataPermissionFilter dataPermissionFilter;
    
    @Around("@annotation(dataPermission)")
    public Object applyDataPermission(ProceedingJoinPoint joinPoint, 
                                    DataPermission dataPermission) throws Throwable {
        
        // 获取当前用户
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()) {
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            Long userId = userDetails.getUserId();
            
            // 设置数据权限上下文
            DataPermissionContext.setUserId(userId);
            DataPermissionContext.setEntity(dataPermission.entity());
            DataPermissionContext.setConditions(dataPermission.conditions());
        }
        
        try {
            return joinPoint.proceed();
        } finally {
            // 清理上下文
            DataPermissionContext.clear();
        }
    }
}
```

## 五、安全监控与审计

### 5.1 安全事件监控

#### 5.1.1 安全事件定义

```java
// 安全事件类型
public enum SecurityEventType {
    LOGIN_SUCCESS("登录成功"),
    LOGIN_FAILURE("登录失败"),
    LOGIN_LOCKED("账户锁定"),
    PASSWORD_CHANGE("密码修改"),
    PERMISSION_DENIED("权限拒绝"),
    DATA_ACCESS("数据访问"),
    SUSPICIOUS_ACTIVITY("可疑活动"),
    SECURITY_VIOLATION("安全违规");
    
    private final String description;
    
    SecurityEventType(String description) {
        this.description = description;
    }
}

// 安全事件实体
@Entity
@Table(name = "security_events")
public class SecurityEvent {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Enumerated(EnumType.STRING)
    private SecurityEventType eventType;
    
    private Long userId;
    
    private String username;
    
    private String ipAddress;
    
    private String userAgent;
    
    private String resource;
    
    private String action;
    
    private String description;
    
    private String riskLevel;
    
    @Column(columnDefinition = "JSON")
    private String eventData;
    
    private LocalDateTime eventTime;
    
    // getters and setters
}
```

#### 5.1.2 安全事件记录

```java
// 安全事件记录服务
@Service
public class SecurityEventService {
    
    @Autowired
    private SecurityEventRepository securityEventRepository;
    
    @Autowired
    private RiskAssessmentService riskAssessmentService;
    
    @Autowired
    private AlertService alertService;
    
    // 记录安全事件
    @Async
    public void recordSecurityEvent(SecurityEventType eventType, Long userId, 
                                  String resource, String action, String description) {
        
        HttpServletRequest request = getCurrentRequest();
        
        SecurityEvent event = new SecurityEvent();
        event.setEventType(eventType);
        event.setUserId(userId);
        event.setUsername(getUsernameById(userId));
        event.setIpAddress(getClientIpAddress(request));
        event.setUserAgent(request.getHeader("User-Agent"));
        event.setResource(resource);
        event.setAction(action);
        event.setDescription(description);
        event.setEventTime(LocalDateTime.now());
        
        // 风险评估
        String riskLevel = riskAssessmentService.assessRisk(event);
        event.setRiskLevel(riskLevel);
        
        // 保存事件
        securityEventRepository.save(event);
        
        // 高风险事件告警
        if ("HIGH".equals(riskLevel) || "CRITICAL".equals(riskLevel)) {
            alertService.sendSecurityAlert(event);
        }
        
        // 检查是否需要自动响应
        checkAutoResponse(event);
    }
    
    // 批量查询安全事件
    public Page<SecurityEvent> findSecurityEvents(SecurityEventQuery query, Pageable pageable) {
        Specification<SecurityEvent> spec = (root, criteriaQuery, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            if (query.getEventType() != null) {
                predicates.add(criteriaBuilder.equal(root.get("eventType"), query.getEventType()));
            }
            
            if (query.getUserId() != null) {
                predicates.add(criteriaBuilder.equal(root.get("userId"), query.getUserId()));
            }
            
            if (query.getStartTime() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(
                    root.get("eventTime"), query.getStartTime()));
            }
            
            if (query.getEndTime() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(
                    root.get("eventTime"), query.getEndTime()));
            }
            
            if (StringUtils.isNotEmpty(query.getRiskLevel())) {
                predicates.add(criteriaBuilder.equal(root.get("riskLevel"), query.getRiskLevel()));
            }
            
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
        
        return securityEventRepository.findAll(spec, pageable);
    }
    
    private void checkAutoResponse(SecurityEvent event) {
        // 检查登录失败次数
        if (event.getEventType() == SecurityEventType.LOGIN_FAILURE) {
            checkLoginFailureCount(event.getUserId(), event.getIpAddress());
        }
        
        // 检查可疑活动
        if (event.getEventType() == SecurityEventType.SUSPICIOUS_ACTIVITY) {
            handleSuspiciousActivity(event);
        }
    }
    
    private void checkLoginFailureCount(Long userId, String ipAddress) {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        
        // 检查用户登录失败次数
        long userFailureCount = securityEventRepository
            .countByUserIdAndEventTypeAndEventTimeAfter(
                userId, SecurityEventType.LOGIN_FAILURE, oneHourAgo);
        
        if (userFailureCount >= 5) {
            // 锁定用户账户
            userService.lockUser(userId, "登录失败次数过多");
            recordSecurityEvent(SecurityEventType.LOGIN_LOCKED, userId, 
                "user", "lock", "账户因登录失败次数过多被锁定");
        }
        
        // 检查IP登录失败次数
        long ipFailureCount = securityEventRepository
            .countByIpAddressAndEventTypeAndEventTimeAfter(
                ipAddress, SecurityEventType.LOGIN_FAILURE, oneHourAgo);
        
        if (ipFailureCount >= 10) {
            // 封禁IP
            ipBlacklistService.addToBlacklist(ipAddress, "登录失败次数过多");
        }
    }
}
```

### 5.2 异常行为检测

#### 5.2.1 行为模式分析

```java
// 用户行为分析服务
@Service
public class UserBehaviorAnalysisService {
    
    @Autowired
    private UserBehaviorRepository userBehaviorRepository;
    
    @Autowired
    private SecurityEventService securityEventService;
    
    // 分析用户登录行为
    public void analyzeLoginBehavior(Long userId, String ipAddress, String userAgent) {
        UserBehaviorProfile profile = getUserBehaviorProfile(userId);
        
        // 检查异常登录时间
        if (isAbnormalLoginTime(profile, LocalDateTime.now())) {
            securityEventService.recordSecurityEvent(
                SecurityEventType.SUSPICIOUS_ACTIVITY, userId,
                "login", "time_anomaly", "异常登录时间");
        }
        
        // 检查异常登录地点
        if (isAbnormalLoginLocation(profile, ipAddress)) {
            securityEventService.recordSecurityEvent(
                SecurityEventType.SUSPICIOUS_ACTIVITY, userId,
                "login", "location_anomaly", "异常登录地点");
        }
        
        // 检查异常设备
        if (isAbnormalDevice(profile, userAgent)) {
            securityEventService.recordSecurityEvent(
                SecurityEventType.SUSPICIOUS_ACTIVITY, userId,
                "login", "device_anomaly", "异常登录设备");
        }
        
        // 更新用户行为档案
        updateBehaviorProfile(userId, ipAddress, userAgent);
    }
    
    // 分析数据访问行为
    public void analyzeDataAccessBehavior(Long userId, String resource, String action) {
        UserBehaviorProfile profile = getUserBehaviorProfile(userId);
        
        // 检查访问频率异常
        if (isAbnormalAccessFrequency(userId, resource, action)) {
            securityEventService.recordSecurityEvent(
                SecurityEventType.SUSPICIOUS_ACTIVITY, userId,
                resource, "frequency_anomaly", "数据访问频率异常");
        }
        
        // 检查批量数据访问
        if (isBulkDataAccess(userId, resource, action)) {
            securityEventService.recordSecurityEvent(
                SecurityEventType.SUSPICIOUS_ACTIVITY, userId,
                resource, "bulk_access", "批量数据访问");
        }
        
        // 检查敏感数据访问
        if (isSensitiveDataAccess(resource) && !isAuthorizedSensitiveAccess(userId, resource)) {
            securityEventService.recordSecurityEvent(
                SecurityEventType.SECURITY_VIOLATION, userId,
                resource, "unauthorized_sensitive_access", "未授权敏感数据访问");
        }
    }
    
    private boolean isAbnormalLoginTime(UserBehaviorProfile profile, LocalDateTime loginTime) {
        // 分析用户历史登录时间模式
        List<Integer> normalHours = profile.getNormalLoginHours();
        int currentHour = loginTime.getHour();
        
        return !normalHours.contains(currentHour);
    }
    
    private boolean isAbnormalLoginLocation(UserBehaviorProfile profile, String ipAddress) {
        // 获取IP地理位置
        GeoLocation location = geoLocationService.getLocation(ipAddress);
        
        // 检查是否在常用地点范围内
        List<GeoLocation> normalLocations = profile.getNormalLocations();
        
        for (GeoLocation normalLocation : normalLocations) {
            double distance = calculateDistance(location, normalLocation);
            if (distance < 100) { // 100公里范围内
                return false;
            }
        }
        
        return true;
    }
    
    private boolean isAbnormalAccessFrequency(Long userId, String resource, String action) {
        LocalDateTime oneHourAgo = LocalDateTime.now().minusHours(1);
        
        long accessCount = securityEventRepository
            .countByUserIdAndResourceAndActionAndEventTimeAfter(
                userId, resource, action, oneHourAgo);
        
        // 根据资源类型设置不同的阈值
        int threshold = getAccessThreshold(resource, action);
        
        return accessCount > threshold;
    }
}
```

### 5.3 审计日志管理

#### 5.3.1 审计日志记录

```java
// 审计日志注解
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AuditLog {
    String operation();
    String resource() default "";
    boolean includeParams() default true;
    boolean includeResult() default false;
}

// 审计日志切面
@Aspect
@Component
public class AuditLogAspect {
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Around("@annotation(auditLog)")
    public Object recordAuditLog(ProceedingJoinPoint joinPoint, AuditLog auditLog) throws Throwable {
        
        AuditLogEntry logEntry = new AuditLogEntry();
        logEntry.setOperation(auditLog.operation());
        logEntry.setResource(auditLog.resource());
        logEntry.setStartTime(LocalDateTime.now());
        
        // 获取用户信息
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()) {
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            logEntry.setUserId(userDetails.getUserId());
            logEntry.setUsername(userDetails.getUsername());
        }
        
        // 获取请求信息
        HttpServletRequest request = getCurrentRequest();
        if (request != null) {
            logEntry.setIpAddress(getClientIpAddress(request));
            logEntry.setUserAgent(request.getHeader("User-Agent"));
            logEntry.setRequestUrl(request.getRequestURL().toString());
            logEntry.setHttpMethod(request.getMethod());
        }
        
        // 记录请求参数
        if (auditLog.includeParams()) {
            Object[] args = joinPoint.getArgs();
            logEntry.setRequestParams(JsonUtils.toJson(args));
        }
        
        Object result = null;
        try {
            result = joinPoint.proceed();
            logEntry.setStatus("SUCCESS");
            
            // 记录返回结果
            if (auditLog.includeResult()) {
                logEntry.setResponseData(JsonUtils.toJson(result));
            }
            
        } catch (Exception e) {
            logEntry.setStatus("FAILURE");
            logEntry.setErrorMessage(e.getMessage());
            throw e;
        } finally {
            logEntry.setEndTime(LocalDateTime.now());
            logEntry.setDuration(Duration.between(logEntry.getStartTime(), logEntry.getEndTime()).toMillis());
            
            // 异步保存审计日志
            auditLogService.saveAuditLog(logEntry);
        }
        
        return result;
    }
}

// 审计日志服务
@Service
public class AuditLogService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    @Autowired
    private AuditLogArchiveService archiveService;
    
    // 保存审计日志
    @Async
    public void saveAuditLog(AuditLogEntry logEntry) {
        try {
            auditLogRepository.save(logEntry);
        } catch (Exception e) {
            log.error("保存审计日志失败", e);
            // 可以考虑写入文件作为备份
            writeToBackupFile(logEntry);
        }
    }
    
    // 查询审计日志
    public Page<AuditLogEntry> findAuditLogs(AuditLogQuery query, Pageable pageable) {
        Specification<AuditLogEntry> spec = (root, criteriaQuery, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            if (query.getUserId() != null) {
                predicates.add(criteriaBuilder.equal(root.get("userId"), query.getUserId()));
            }
            
            if (StringUtils.isNotEmpty(query.getOperation())) {
                predicates.add(criteriaBuilder.like(root.get("operation"), "%" + query.getOperation() + "%"));
            }
            
            if (StringUtils.isNotEmpty(query.getResource())) {
                predicates.add(criteriaBuilder.like(root.get("resource"), "%" + query.getResource() + "%"));
            }
            
            if (query.getStartTime() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(
                    root.get("startTime"), query.getStartTime()));
            }
            
            if (query.getEndTime() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(
                    root.get("endTime"), query.getEndTime()));
            }
            
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
        
        return auditLogRepository.findAll(spec, pageable);
    }
    
    // 归档审计日志
    @Scheduled(cron = "0 0 2 1 * ?") // 每月1号凌晨2点执行
    public void archiveAuditLogs() {
        LocalDateTime archiveDate = LocalDateTime.now().minusMonths(3);
        
        List<AuditLogEntry> logsToArchive = auditLogRepository
            .findByStartTimeBefore(archiveDate);
        
        if (!logsToArchive.isEmpty()) {
            // 归档到文件或其他存储
            archiveService.archive(logsToArchive);
            
            // 删除已归档的日志
            auditLogRepository.deleteAll(logsToArchive);
            
            log.info("归档审计日志 {} 条", logsToArchive.size());
        }
    }
}
```

## 六、网络安全防护

### 6.1 HTTPS与传输安全

#### 6.1.1 SSL/TLS配置

```yaml
# HTTPS配置
server:
  port: 8443
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: ${SSL_KEYSTORE_PASSWORD}
    key-store-type: PKCS12
    key-alias: multishop
    # 强制使用TLS 1.2+
    protocol: TLS
    enabled-protocols: TLSv1.2,TLSv1.3
    # 安全的密码套件
    ciphers: 
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
      - TLS_DHE_RSA_WITH_AES_128_GCM_SHA256

# HTTP重定向到HTTPS
security:
  require-ssl: true
  headers:
    # 强制HTTPS
    content-security-policy: "upgrade-insecure-requests"
    # HSTS
    strict-transport-security: "max-age=31536000; includeSubDomains; preload"
    # 防止点击劫持
    frame-options: DENY
    # 防止MIME类型嗅探
    content-type-options: nosniff
    # XSS保护
    xss-protection: "1; mode=block"
```

#### 6.1.2 证书管理

```java
// SSL证书管理服务
@Service
public class SslCertificateService {
    
    @Value("${server.ssl.key-store}")
    private String keystorePath;
    
    @Value("${server.ssl.key-store-password}")
    private String keystorePassword;
    
    // 检查证书有效期
    @Scheduled(cron = "0 0 6 * * ?") // 每天早上6点检查
    public void checkCertificateExpiry() {
        try {
            KeyStore keystore = loadKeystore();
            Enumeration<String> aliases = keystore.aliases();
            
            while (aliases.hasMoreElements()) {
                String alias = aliases.nextElement();
                X509Certificate cert = (X509Certificate) keystore.getCertificate(alias);
                
                Date expiryDate = cert.getNotAfter();
                long daysUntilExpiry = ChronoUnit.DAYS.between(
                    LocalDate.now(), 
                    expiryDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate()
                );
                
                if (daysUntilExpiry <= 30) {
                    // 证书即将过期，发送告警
                    alertService.sendCertificateExpiryAlert(alias, expiryDate);
                }
                
                if (daysUntilExpiry <= 7) {
                    // 证书即将过期，发送紧急告警
                    alertService.sendUrgentCertificateExpiryAlert(alias, expiryDate);
                }
            }
        } catch (Exception e) {
            log.error("检查证书有效期失败", e);
        }
    }
    
    // 自动续期证书（Let's Encrypt）
    public void renewCertificate() {
        try {
            // 使用ACME客户端自动续期
            AcmeClient acmeClient = new AcmeClient();
            Certificate newCert = acmeClient.renewCertificate();
            
            // 更新keystore
            updateKeystore(newCert);
            
            // 重启服务器以加载新证书
            restartServer();
            
        } catch (Exception e) {
            log.error("证书续期失败", e);
            alertService.sendCertificateRenewalFailureAlert(e);
        }
    }
}
```

### 6.2 防火墙与访问控制

#### 6.2.1 IP白名单/黑名单

```java
// IP访问控制服务
@Service
public class IpAccessControlService {
    
    @Autowired
    private IpWhitelistRepository ipWhitelistRepository;
    
    @Autowired
    private IpBlacklistRepository ipBlacklistRepository;
    
    // 检查IP是否被允许访问
    public boolean isIpAllowed(String ipAddress) {
        // 检查黑名单
        if (isInBlacklist(ipAddress)) {
            return false;
        }
        
        // 检查白名单（如果启用）
        if (isWhitelistEnabled() && !isInWhitelist(ipAddress)) {
            return false;
        }
        
        return true;
    }
    
    // 添加到黑名单
    public void addToBlacklist(String ipAddress, String reason) {
        IpBlacklist blacklist = new IpBlacklist();
        blacklist.setIpAddress(ipAddress);
        blacklist.setReason(reason);
        blacklist.setCreatedAt(LocalDateTime.now());
        blacklist.setExpiresAt(LocalDateTime.now().plusDays(1)); // 默认封禁1天
        
        ipBlacklistRepository.save(blacklist);
        
        log.info("IP {} 已添加到黑名单，原因: {}", ipAddress, reason);
    }
    
    // 添加到白名单
    public void addToWhitelist(String ipAddress, String description) {
        IpWhitelist whitelist = new IpWhitelist();
        whitelist.setIpAddress(ipAddress);
        whitelist.setDescription(description);
        whitelist.setCreatedAt(LocalDateTime.now());
        
        ipWhitelistRepository.save(whitelist);
        
        log.info("IP {} 已添加到白名单", ipAddress);
    }
    
    private boolean isInBlacklist(String ipAddress) {
        return ipBlacklistRepository.existsByIpAddressAndExpiresAtAfter(
            ipAddress, LocalDateTime.now());
    }
    
    private boolean isInWhitelist(String ipAddress) {
        return ipWhitelistRepository.existsByIpAddress(ipAddress);
    }
}

// IP访问控制过滤器
@Component
public class IpAccessControlFilter implements Filter {
    
    @Autowired
    private IpAccessControlService ipAccessControlService;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        String clientIp = getClientIpAddress(httpRequest);
        
        if (!ipAccessControlService.isIpAllowed(clientIp)) {
            httpResponse.setStatus(HttpStatus.FORBIDDEN.value());
            httpResponse.getWriter().write("Access denied");
            return;
        }
        
        chain.doFilter(request, response);
    }
    
    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        
        return request.getRemoteAddr();
    }
}
```

### 6.3 DDoS防护

#### 6.3.1 限流策略

```java
// 限流配置
@Configuration
public class RateLimitConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
    
    @Bean
    public RateLimiter globalRateLimiter() {
        return RateLimiter.create(1000.0); // 全局每秒1000个请求
    }
}

// 限流注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    int value() default 10; // 每分钟请求次数
    int window() default 60; // 时间窗口（秒）
    String key() default ""; // 限流key
    RateLimitType type() default RateLimitType.IP;
}

// 限流类型
public enum RateLimitType {
    IP,     // 按IP限流
    USER,   // 按用户限流
    API,    // 按API限流
    GLOBAL  // 全局限流
}

// 限流切面
@Aspect
@Component
public class RateLimitAspect {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Around("@annotation(rateLimit)")
    public Object rateLimit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        
        String key = generateRateLimitKey(joinPoint, rateLimit);
        
        if (!checkRateLimit(key, rateLimit.value(), rateLimit.window())) {
            throw new RateLimitExceededException("请求过于频繁，请稍后再试");
        }
        
        return joinPoint.proceed();
    }
    
    private String generateRateLimitKey(ProceedingJoinPoint joinPoint, RateLimit rateLimit) {
        StringBuilder keyBuilder = new StringBuilder("rate_limit:");
        
        switch (rateLimit.type()) {
            case IP:
                keyBuilder.append("ip:").append(getClientIpAddress());
                break;
            case USER:
                keyBuilder.append("user:").append(getCurrentUserId());
                break;
            case API:
                keyBuilder.append("api:").append(joinPoint.getSignature().getName());
                break;
            case GLOBAL:
                keyBuilder.append("global");
                break;
        }
        
        if (StringUtils.isNotEmpty(rateLimit.key())) {
            keyBuilder.append(":").append(rateLimit.key());
        }
        
        return keyBuilder.toString();
    }
    
    private boolean checkRateLimit(String key, int limit, int window) {
        try {
            String script = 
                "local key = KEYS[1] " +
                "local window = tonumber(ARGV[1]) " +
                "local limit = tonumber(ARGV[2]) " +
                "local current = redis.call('GET', key) " +
                "if current == false then " +
                "    redis.call('SET', key, 1) " +
                "    redis.call('EXPIRE', key, window) " +
                "    return 1 " +
                "else " +
                "    local count = tonumber(current) " +
                "    if count < limit then " +
                "        redis.call('INCR', key) " +
                "        return 1 " +
                "    else " +
                "        return 0 " +
                "    end " +
                "end";
            
            DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
            redisScript.setScriptText(script);
            redisScript.setResultType(Long.class);
            
            Long result = redisTemplate.execute(redisScript, 
                Collections.singletonList(key), window, limit);
            
            return result != null && result == 1;
            
        } catch (Exception e) {
            log.error("限流检查失败", e);
            return true; // 异常时允许通过
        }
    }
}
```

## 七、安全配置与部署

### 7.1 安全配置管理

#### 7.1.1 配置文件安全

```yaml
# 生产环境安全配置
spring:
  profiles:
    active: prod
    
  # 数据库配置
  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:multishop}?useSSL=true&requireSSL=true&verifyServerCertificate=true
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      
  # Redis配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD}
    ssl: true
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5

# 安全配置
security:
  # JWT配置
  jwt:
    secret: ${JWT_SECRET}
    expiration: 7200
    
  # 加密配置
  encryption:
    algorithm: AES-256-GCM
    key-derivation: PBKDF2
    iterations: 100000
    
  # 密码策略
  password:
    min-length: 8
    max-length: 128
    require-uppercase: true
    require-lowercase: true
    require-numbers: true
    require-special-chars: true
    
  # 会话配置
  session:
    timeout: 1800
    max-concurrent: 5
    
# 日志配置
logging:
  level:
    com.multishop.security: INFO
    org.springframework.security: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: /var/log/multishop/application.log
    max-size: 100MB
    max-history: 30
```

#### 7.1.2 环境变量管理

```bash
#!/bin/bash
# 环境变量配置脚本

# 数据库配置
export DB_HOST="prod-db-cluster.example.com"
export DB_PORT="3306"
export DB_NAME="multishop_prod"
export DB_USERNAME="multishop_user"
export DB_PASSWORD="$(cat /etc/secrets/db_password)"

# Redis配置
export REDIS_HOST="prod-redis-cluster.example.com"
export REDIS_PORT="6379"
export REDIS_PASSWORD="$(cat /etc/secrets/redis_password)"

# JWT密钥
export JWT_SECRET="$(cat /etc/secrets/jwt_secret)"

# 加密密钥
export ENCRYPTION_KEY="$(cat /etc/secrets/encryption_key)"

# SSL证书密码
export SSL_KEYSTORE_PASSWORD="$(cat /etc/secrets/ssl_password)"

# 第三方服务配置
export SMS_API_KEY="$(cat /etc/secrets/sms_api_key)"
export EMAIL_PASSWORD="$(cat /etc/secrets/email_password)"

# 监控配置
export MONITORING_TOKEN="$(cat /etc/secrets/monitoring_token)"

echo "环境变量配置完成"
```

### 7.2 容器安全

#### 7.2.1 Docker安全配置

```dockerfile
# 多阶段构建，减少攻击面
FROM openjdk:11-jdk-slim AS builder

WORKDIR /app
COPY . .
RUN ./mvnw clean package -DskipTests

# 运行时镜像
FROM openjdk:11-jre-slim

# 创建非root用户
RUN groupadd -r multishop && useradd -r -g multishop multishop

# 安装安全更新
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
        ca-certificates \
        curl && \
    rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 复制应用文件
COPY --from=builder /app/target/multishop-user-*.jar app.jar

# 设置文件权限
RUN chown -R multishop:multishop /app
RUN chmod 755 /app/app.jar

# 切换到非root用户
USER multishop

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# 启动应用
ENTRYPOINT ["java", \
    "-Djava.security.egd=file:/dev/./urandom", \
    "-Dspring.profiles.active=prod", \
    "-Xms512m", \
    "-Xmx1024m", \
    "-jar", \
    "app.jar"]
```

#### 7.2.2 Kubernetes安全配置

```yaml
# 安全策略
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: multishop-user-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'

---
# 网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: multishop-user-netpol
spec:
  podSelector:
    matchLabels:
      app: multishop-user
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: multishop-gateway
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: multishop-database
    ports:
    - protocol: TCP
      port: 3306
  - to:
    - namespaceSelector:
        matchLabels:
          name: multishop-redis
    ports:
    - protocol: TCP
      port: 6379

---
# 部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: multishop-user
spec:
  replicas: 3
  selector:
    matchLabels:
      app: multishop-user
  template:
    metadata:
      labels:
        app: multishop-user
    spec:
      serviceAccountName: multishop-user-sa
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
      containers:
      - name: multishop-user
        image: multishop/user:latest
        ports:
        - containerPort: 8080
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

## 八、安全测试与验证

### 8.1 安全测试策略

#### 8.1.1 自动化安全测试

```java
// 安全测试基类
@SpringBootTest
@AutoConfigureMockMvc
public abstract class SecurityTestBase {
    
    @Autowired
    protected MockMvc mockMvc;
    
    @Autowired
    protected ObjectMapper objectMapper;
    
    protected String generateValidJwtToken(Long userId) {
        // 生成有效的JWT令牌用于测试
        return jwtTokenService.generateAccessToken(createUserDetails(userId));
    }
    
    protected String generateExpiredJwtToken(Long userId) {
        // 生成过期的JWT令牌用于测试
        return jwtTokenService.generateExpiredToken(createUserDetails(userId));
    }
    
    protected UserDetails createUserDetails(Long userId) {
        return new CustomUserDetails(userId, "testuser", "password", 
            Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));
    }
}

// 认证安全测试
@TestMethodOrder(OrderAnnotation.class)
public class AuthenticationSecurityTest extends SecurityTestBase {
    
    @Test
    @Order(1)
    @DisplayName("测试SQL注入防护")
    public void testSqlInjectionProtection() throws Exception {
        String maliciousUsername = "admin'; DROP TABLE users; --";
        
        LoginRequest request = new LoginRequest();
        request.setUsername(maliciousUsername);
        request.setPassword("password");
        
        mockMvc.perform(post("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value("用户名或密码错误"));
        
        // 验证数据库表仍然存在
        assertThat(userRepository.count()).isGreaterThan(0);
    }
    
    @Test
    @Order(2)
    @DisplayName("测试XSS防护")
    public void testXssProtection() throws Exception {
        String xssPayload = "<script>alert('XSS')</script>";
        
        RegisterRequest request = new RegisterRequest();
        request.setUsername(xssPayload);
        request.setPassword("Password123!");
        request.setEmail("test@example.com");
        
        mockMvc.perform(post("/api/auth/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("用户名包含非法字符"));
    }
    
    @Test
    @Order(3)
    @DisplayName("测试暴力破解防护")
    public void testBruteForceProtection() throws Exception {
        String username = "testuser";
        String wrongPassword = "wrongpassword";
        
        LoginRequest request = new LoginRequest();
        request.setUsername(username);
        request.setPassword(wrongPassword);
        
        // 连续5次错误登录
        for (int i = 0; i < 5; i++) {
            mockMvc.perform(post("/api/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
                    .andExpect(status().isUnauthorized());
        }
        
        // 第6次应该被锁定
        mockMvc.perform(post("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isLocked())
                .andExpect(jsonPath("$.message").value("账户已被锁定"));
    }
    
    @Test
    @Order(4)
    @DisplayName("测试JWT令牌安全")
    public void testJwtTokenSecurity() throws Exception {
        // 测试无效令牌
        mockMvc.perform(get("/api/user/profile")
                .header("Authorization", "Bearer invalid_token"))
                .andExpect(status().isUnauthorized());
        
        // 测试过期令牌
        String expiredToken = generateExpiredJwtToken(1L);
        mockMvc.perform(get("/api/user/profile")
                .header("Authorization", "Bearer " + expiredToken))
                .andExpect(status().isUnauthorized());
        
        // 测试篡改令牌
        String validToken = generateValidJwtToken(1L);
        String tamperedToken = validToken.substring(0, validToken.length() - 5) + "XXXXX";
        mockMvc.perform(get("/api/user/profile")
                .header("Authorization", "Bearer " + tamperedToken))
                .andExpected(status().isUnauthorized());
    }
}

// 权限控制测试
public class AuthorizationSecurityTest extends SecurityTestBase {
    
    @Test
    @DisplayName("测试垂直权限控制")
    public void testVerticalAccessControl() throws Exception {
        // 普通用户尝试访问管理员功能
        String userToken = generateValidJwtToken(1L); // 普通用户
        
        mockMvc.perform(get("/api/admin/users")
                .header("Authorization", "Bearer " + userToken))
                .andExpect(status().isForbidden());
    }
    
    @Test
    @DisplayName("测试水平权限控制")
    public void testHorizontalAccessControl() throws Exception {
        // 用户A尝试访问用户B的数据
        String userAToken = generateValidJwtToken(1L);
        Long userBId = 2L;
        
        mockMvc.perform(get("/api/user/" + userBId + "/profile")
                .header("Authorization", "Bearer " + userAToken))
                .andExpect(status().isForbidden());
    }
}
```

#### 8.1.2 渗透测试清单

```markdown
# 用户模块安全渗透测试清单

## 1. 认证安全测试

### 1.1 密码安全
- [ ] 弱密码检测
- [ ] 密码复杂度验证
- [ ] 密码历史检查
- [ ] 密码加密存储验证

### 1.2 登录安全
- [ ] 暴力破解防护
- [ ] 账户锁定机制
- [ ] 验证码绕过测试
- [ ] 会话固定攻击

### 1.3 多因素认证
- [ ] TOTP绕过测试
- [ ] 短信验证码安全
- [ ] 备用验证方式安全

## 2. 会话管理测试

### 2.1 JWT安全
- [ ] 令牌篡改测试
- [ ] 令牌重放攻击
- [ ] 令牌过期验证
- [ ] 令牌撤销机制

### 2.2 会话安全
- [ ] 会话劫持测试
- [ ] 并发会话控制
- [ ] 会话超时验证
- [ ] 安全登出测试

## 3. 输入验证测试

### 3.1 注入攻击
- [ ] SQL注入测试
- [ ] NoSQL注入测试
- [ ] LDAP注入测试
- [ ] 命令注入测试

### 3.2 跨站攻击
- [ ] XSS攻击测试
- [ ] CSRF攻击测试
- [ ] 点击劫持测试
- [ ] 开放重定向测试

## 4. 权限控制测试

### 4.1 访问控制
- [ ] 垂直权限提升
- [ ] 水平权限提升
- [ ] 直接对象引用
- [ ] 功能级访问控制

### 4.2 数据权限
- [ ] 敏感数据泄露
- [ ] 数据权限绕过
- [ ] 批量数据访问
- [ ] 数据导出安全

## 5. 业务逻辑测试

### 5.1 注册流程
- [ ] 重复注册测试
- [ ] 邮箱验证绕过
- [ ] 手机验证绕过
- [ ] 恶意注册防护

### 5.2 密码重置
- [ ] 重置令牌安全
- [ ] 重置流程绕过
- [ ] 账户接管测试
- [ ] 重置频率限制

## 6. 数据安全测试

### 6.1 敏感数据
- [ ] 数据加密验证
- [ ] 数据脱敏测试
- [ ] 数据传输安全
- [ ] 数据存储安全

### 6.2 隐私保护
- [ ] 个人信息泄露
- [ ] 数据最小化原则
- [ ] 数据删除验证
- [ ] 隐私设置测试
```

## 九、应急响应计划

### 9.1 安全事件分类

#### 9.1.1 事件等级定义

| 等级 | 描述 | 响应时间 | 处理团队 |
|------|------|----------|----------|
| P0 - 紧急 | 系统完全不可用，大量用户数据泄露 | 15分钟 | 全体安全团队 |
| P1 - 高 | 部分功能不可用，少量敏感数据泄露 | 1小时 | 安全团队 + 开发团队 |
| P2 - 中 | 功能异常，潜在安全风险 | 4小时 | 安全团队 |
| P3 - 低 | 轻微安全问题，无直接影响 | 24小时 | 值班人员 |

#### 9.1.2 应急响应流程

```java
// 安全事件响应服务
@Service
public class SecurityIncidentResponseService {
    
    @Autowired
    private AlertService alertService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AuditLogService auditLogService;
    
    // 处理安全事件
    public void handleSecurityIncident(SecurityIncident incident) {
        try {
            // 1. 事件分类和评级
            IncidentLevel level = classifyIncident(incident);
            incident.setLevel(level);
            
            // 2. 立即响应措施
            executeImmediateResponse(incident);
            
            // 3. 通知相关人员
            notifyStakeholders(incident);
            
            // 4. 启动调查流程
            initiateInvestigation(incident);
            
            // 5. 记录事件日志
            auditLogService.recordIncident(incident);
            
        } catch (Exception e) {
            log.error("处理安全事件失败", e);
            // 发送紧急告警
            alertService.sendEmergencyAlert("安全事件处理失败: " + e.getMessage());
        }
    }
    
    // 立即响应措施
    private void executeImmediateResponse(SecurityIncident incident) {
        switch (incident.getType()) {
            case DATA_BREACH:
                handleDataBreach(incident);
                break;
            case ACCOUNT_COMPROMISE:
                handleAccountCompromise(incident);
                break;
            case SYSTEM_INTRUSION:
                handleSystemIntrusion(incident);
                break;
            case DDOS_ATTACK:
                handleDdosAttack(incident);
                break;
            default:
                handleGenericIncident(incident);
        }
    }
    
    // 处理数据泄露事件
    private void handleDataBreach(SecurityIncident incident) {
        // 1. 立即隔离受影响的系统
        isolateAffectedSystems(incident.getAffectedSystems());
        
        // 2. 停止数据处理
        suspendDataProcessing(incident.getAffectedDataTypes());
        
        // 3. 保护现场证据
        preserveEvidence(incident);
        
        // 4. 评估泄露范围
        assessBreachScope(incident);
        
        // 5. 通知监管机构（如需要）
        if (requiresRegulatoryNotification(incident)) {
            notifyRegulators(incident);
        }
    }
    
    // 处理账户被盗事件
    private void handleAccountCompromise(SecurityIncident incident) {
        List<Long> compromisedUserIds = incident.getAffectedUserIds();
        
        for (Long userId : compromisedUserIds) {
            // 1. 立即锁定账户
            userService.lockUser(userId, "安全事件：账户可能被盗");
            
            // 2. 撤销所有会话
            sessionManagementService.terminateAllUserSessions(userId);
            
            // 3. 撤销所有令牌
            tokenService.revokeAllUserTokens(userId);
            
            // 4. 强制密码重置
            passwordService.forcePasswordReset(userId);
            
            // 5. 通知用户
            notificationService.sendSecurityAlert(userId, incident);
        }
    }
}
```

### 9.2 灾难恢复计划

#### 9.2.1 备份恢复策略

```yaml
# 灾难恢复配置
disaster-recovery:
  # RTO: 恢复时间目标
  rto: 4h
  # RPO: 恢复点目标  
  rpo: 1h
  
  # 备份策略
  backup:
    # 数据库备份
    database:
      full-backup-schedule: "0 0 2 * * ?"
      incremental-backup-schedule: "0 0 */6 * * ?"
      retention-days: 30
      
    # 文件备份
    files:
      backup-schedule: "0 0 3 * * ?"
      retention-days: 30
      
    # 配置备份
    config:
      backup-schedule: "0 0 1 * * ?"
      retention-days: 90
      
  # 恢复策略
  recovery:
    # 主站点恢复
    primary-site:
      max-downtime: 2h
      auto-failback: true
      
    # 灾备站点
    disaster-site:
      location: "backup-datacenter"
      auto-failover: true
      sync-interval: 15m
      
  # 测试计划
  testing:
    schedule: "quarterly"
    scope: "full-system"
    documentation: true
```

## 十、总结

本用户模块安全设计文档涵盖了以下关键安全领域：

### 10.1 核心安全特性

1. **多层身份认证**：密码、多因素认证、生物识别
2. **细粒度权限控制**：基于RBAC的访问控制和数据权限
3. **数据安全保护**：端到端加密、数据脱敏、安全存储
4. **实时安全监控**：异常检测、审计日志、安全告警
5. **网络安全防护**：HTTPS、防火墙、DDoS防护
6. **安全运维管理**：配置安全、容器安全、应急响应

### 10.2 安全合规

- 符合GDPR数据保护要求
- 满足等保2.0安全标准
- 遵循OWASP安全最佳实践
- 支持SOX合规审计要求

### 10.3 持续改进

安全是一个持续改进的过程，需要：

1. **定期安全评估**：季度安全审计和渗透测试
2. **威胁情报更新**：跟踪最新安全威胁和漏洞
3. **安全培训**：提升团队安全意识和技能
4. **技术更新**：及时更新安全组件和修复漏洞

通过实施本安全设计，用户模块将具备企业级的安全防护能力，为用户数据和业务系统提供全面的安全保障。