# 用户模块系统架构设计文档

## 一、架构概述

### 1.1 设计原则

- **高可用性**：采用微服务架构，支持水平扩展和故障隔离
- **高性能**：使用缓存机制和数据库优化，确保快速响应
- **安全性**：多层安全防护，数据加密和权限控制
- **可扩展性**：模块化设计，便于功能扩展和维护
- **一致性**：统一的接口规范和数据格式

### 1.2 技术栈选型

| 技术分层 | 技术选型 | 版本 | 说明 |
|----------|----------|------|------|
| 开发语言 | Java | 17 | 主要开发语言 |
| 框架 | Spring Boot | 2.7.x | 微服务框架 |
| 微服务 | Spring Cloud Alibaba | 2021.x | 微服务治理 |
| 数据库 | MySQL | 8.0 | 主数据库 |
| 缓存 | Redis | 6.2 | 分布式缓存 |
| 消息队列 | RocketMQ | 4.9 | 异步消息处理 |
| 搜索引擎 | Elasticsearch | 7.14 | 用户搜索和日志分析 |
| 容器化 | Docker | 20.x | 容器化部署 |
| 编排工具 | Kubernetes | 1.24 | 容器编排 |

### 1.3 架构分层

```
┌─────────────────────────────────────────────────────────────┐
│                        客户端层                              │
│  Web端(Vue3) │ 移动端(Flutter) │ 小程序 │ 第三方系统        │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                        网关层                                │
│              Spring Cloud Gateway                           │
│        (路由、限流、认证、监控)                              │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                        服务层                                │
│  用户服务 │ 认证服务 │ 通知服务 │ 文件服务 │ 其他业务服务    │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                        数据层                                │
│    MySQL    │    Redis    │  RocketMQ  │ Elasticsearch     │
└─────────────────────────────────────────────────────────────┘
```

## 二、服务架构设计

### 2.1 微服务拆分

#### 2.1.1 用户核心服务 (msc-user-core)

**职责范围：**
- 用户基础信息管理
- 用户注册登录
- 个人资料维护
- 收货地址管理

**核心模块：**
```
msc-user-core/
├── controller/          # 控制层
│   ├── UserController
│   ├── ProfileController
│   └── AddressController
├── service/            # 服务层
│   ├── UserService
│   ├── ProfileService
│   └── AddressService
├── repository/         # 数据访问层
│   ├── UserRepository
│   ├── ProfileRepository
│   └── AddressRepository
├── entity/            # 实体层
│   ├── User
│   ├── UserProfile
│   └── UserAddress
└── dto/               # 数据传输对象
    ├── request/
    └── response/
```

#### 2.1.2 认证授权服务 (msc-user-auth)

**职责范围：**
- JWT Token管理
- 用户认证验证
- 权限控制
- 第三方登录集成

**核心模块：**
```
msc-user-auth/
├── controller/
│   ├── AuthController
│   ├── TokenController
│   └── OAuthController
├── service/
│   ├── AuthService
│   ├── TokenService
│   ├── JwtService
│   └── OAuthService
├── security/
│   ├── JwtAuthenticationFilter
│   ├── SecurityConfig
│   └── PasswordEncoder
└── integration/
    ├── WechatOAuthClient
    └── AlipayOAuthClient
```

#### 2.1.3 会员积分服务 (msc-user-member)

**职责范围：**
- 会员等级管理
- 积分获取和消费
- 会员权益计算
- 积分明细记录

**核心模块：**
```
msc-user-member/
├── controller/
│   ├── MemberController
│   └── PointsController
├── service/
│   ├── MemberService
│   ├── PointsService
│   └── MemberLevelService
├── repository/
│   ├── MemberRepository
│   └── PointsLogRepository
└── scheduler/
    └── MemberLevelUpdateScheduler
```

#### 2.1.4 消息通知服务 (msc-user-notification)

**职责范围：**
- 短信通知发送
- 邮件通知发送
- APP推送通知
- 消息模板管理

**核心模块：**
```
msc-user-notification/
├── controller/
│   └── NotificationController
├── service/
│   ├── SmsService
│   ├── EmailService
│   ├── PushService
│   └── TemplateService
├── integration/
│   ├── SmsProvider
│   ├── EmailProvider
│   └── PushProvider
└── template/
    └── MessageTemplate
```

### 2.2 服务间通信

#### 2.2.1 同步通信
- **OpenFeign**：服务间HTTP调用
- **负载均衡**：Ribbon实现客户端负载均衡
- **熔断降级**：Hystrix实现服务熔断

#### 2.2.2 异步通信
- **消息队列**：RocketMQ处理异步消息
- **事件驱动**：基于事件的松耦合架构
- **最终一致性**：分布式事务处理

### 2.3 数据一致性

#### 2.3.1 分布式事务
```java
// 使用Seata实现分布式事务
@GlobalTransactional
public void registerUser(UserRegisterRequest request) {
    // 1. 创建用户基础信息
    userCoreService.createUser(request);
    
    // 2. 初始化会员信息
    memberService.initMember(request.getUserId());
    
    // 3. 发送欢迎消息
    notificationService.sendWelcomeMessage(request.getUserId());
}
```

#### 2.3.2 缓存一致性
```java
// 缓存更新策略
@CacheEvict(value = "user", key = "#userId")
public void updateUserProfile(Long userId, UserProfile profile) {
    // 1. 更新数据库
    userRepository.updateProfile(userId, profile);
    
    // 2. 发送缓存失效消息
    cacheInvalidationService.invalidateUserCache(userId);
}
```

## 三、技术架构设计

### 3.1 缓存架构

#### 3.1.1 多级缓存策略

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   本地缓存       │    │   分布式缓存     │    │     数据库       │
│   (Caffeine)    │    │    (Redis)      │    │    (MySQL)      │
│   - 热点数据     │    │   - 用户信息     │    │   - 持久化数据   │
│   - 1分钟TTL    │    │   - 30分钟TTL   │    │   - 主从架构     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

#### 3.1.2 缓存Key设计规范

```java
// 缓存Key命名规范
public class CacheKeys {
    // 用户基础信息: user:info:{userId}
    public static final String USER_INFO = "user:info:%d";
    
    // 用户权限信息: user:permission:{userId}
    public static final String USER_PERMISSION = "user:permission:%d";
    
    // 用户会话信息: user:session:{token}
    public static final String USER_SESSION = "user:session:%s";
    
    // 验证码: user:captcha:{phone}
    public static final String USER_CAPTCHA = "user:captcha:%s";
}
```

### 3.2 安全架构

#### 3.2.1 认证流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Gateway as 网关
    participant Auth as 认证服务
    participant User as 用户服务
    participant Redis as Redis缓存

    Client->>Gateway: 1. 登录请求
    Gateway->>Auth: 2. 转发认证请求
    Auth->>User: 3. 验证用户信息
    User-->>Auth: 4. 返回用户信息
    Auth->>Redis: 5. 存储会话信息
    Auth-->>Gateway: 6. 返回JWT Token
    Gateway-->>Client: 7. 返回登录结果
    
    Client->>Gateway: 8. 业务请求(携带Token)
    Gateway->>Auth: 9. Token验证
    Auth->>Redis: 10. 查询会话信息
    Redis-->>Auth: 11. 返回会话状态
    Auth-->>Gateway: 12. 验证结果
    Gateway->>User: 13. 转发业务请求
    User-->>Gateway: 14. 返回业务结果
    Gateway-->>Client: 15. 返回最终结果
```

#### 3.2.2 权限控制模型

```java
// RBAC权限模型
@Entity
public class Role {
    private Long id;
    private String roleName;
    private String roleCode;
    private List<Permission> permissions;
}

@Entity
public class Permission {
    private Long id;
    private String permissionName;
    private String permissionCode;
    private String resourceUrl;
}

@Entity
public class UserRole {
    private Long userId;
    private Long roleId;
    private Date createTime;
}
```

### 3.3 监控架构

#### 3.3.1 监控指标

| 监控类型 | 监控指标 | 告警阈值 | 处理方式 |
|----------|----------|----------|----------|
| 应用监控 | QPS | >1000/s | 自动扩容 |
| 应用监控 | 响应时间 | >2s | 告警通知 |
| 应用监控 | 错误率 | >1% | 立即告警 |
| 系统监控 | CPU使用率 | >80% | 自动扩容 |
| 系统监控 | 内存使用率 | >85% | 告警通知 |
| 数据库监控 | 连接数 | >80% | 告警通知 |
| 缓存监控 | 命中率 | <90% | 优化缓存 |

#### 3.3.2 日志架构

```
应用日志 → Logback → Kafka → Elasticsearch → Kibana
                                    ↓
                              日志分析和告警
```

## 四、数据架构设计

### 4.1 数据库架构

#### 4.1.1 主从架构

```
┌─────────────────┐    ┌─────────────────┐
│   主数据库       │    │   从数据库1      │
│   (Master)      │───▶│   (Slave1)      │
│   - 写操作       │    │   - 读操作       │
│   - 主要读操作   │    │   - 备份恢复     │
└─────────────────┘    └─────────────────┘
         │                       │
         │              ┌─────────────────┐
         └─────────────▶│   从数据库2      │
                        │   (Slave2)      │
                        │   - 读操作       │
                        │   - 数据分析     │
                        └─────────────────┘
```

#### 4.1.2 分库分表策略

```java
// 用户表分表策略
@TableName("user")
@TableShard(shardingColumn = "id", shardingAlgorithm = "hash_mod")
public class User {
    // 按用户ID取模分表，支持16个分表
    // user_0, user_1, ..., user_15
}

// 积分记录表分表策略
@TableName("user_points_log")
@TableShard(shardingColumn = "user_id", shardingAlgorithm = "range")
public class UserPointsLog {
    // 按用户ID范围分表，每100万用户一个表
    // user_points_log_0 (1-1000000)
    // user_points_log_1 (1000001-2000000)
}
```

### 4.2 缓存设计

#### 4.2.1 Redis集群架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Redis主节点1   │    │   Redis主节点2   │    │   Redis主节点3   │
│   (Master1)     │    │   (Master2)     │    │   (Master3)     │
│   Slot: 0-5460  │    │ Slot: 5461-10922│    │Slot: 10923-16383│
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Redis从节点1   │    │   Redis从节点2   │    │   Redis从节点3   │
│   (Slave1)      │    │   (Slave2)      │    │   (Slave3)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

#### 4.2.2 缓存策略

```java
// 缓存策略配置
@Configuration
public class CacheConfig {
    
    // 用户基础信息缓存 - 30分钟
    @Bean
    public CacheManager userCacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration(Duration.ofMinutes(30)));
        return builder.build();
    }
    
    // 验证码缓存 - 5分钟
    @Bean
    public CacheManager captchaCacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration(Duration.ofMinutes(5)));
        return builder.build();
    }
}
```

## 五、部署架构设计

### 5.1 容器化部署

#### 5.1.1 Docker镜像构建

```dockerfile
# 用户服务Dockerfile
FROM openjdk:17-jre-slim

LABEL maintainer="MultiShopCore Team"

# 设置工作目录
WORKDIR /app

# 复制应用程序
COPY target/msc-user-*.jar app.jar

# 设置JVM参数
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### 5.1.2 Kubernetes部署配置

```yaml
# 用户服务部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: msc-user-core
  namespace: multishop
spec:
  replicas: 3
  selector:
    matchLabels:
      app: msc-user-core
  template:
    metadata:
      labels:
        app: msc-user-core
    spec:
      containers:
      - name: msc-user-core
        image: multishop/msc-user-core:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: MYSQL_HOST
          valueFrom:
            configMapKeyRef:
              name: database-config
              key: mysql.host
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: msc-user-core-service
  namespace: multishop
spec:
  selector:
    app: msc-user-core
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
```

### 5.2 环境配置

#### 5.2.1 配置管理

```yaml
# ConfigMap配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-service-config
  namespace: multishop
data:
  application.yml: |
    server:
      port: 8080
    spring:
      application:
        name: msc-user-core
      datasource:
        url: jdbc:mysql://${MYSQL_HOST}:3306/multishop_user?useSSL=false&serverTimezone=Asia/Shanghai
        username: ${MYSQL_USERNAME}
        password: ${MYSQL_PASSWORD}
        driver-class-name: com.mysql.cj.jdbc.Driver
      redis:
        host: ${REDIS_HOST}
        port: 6379
        password: ${REDIS_PASSWORD}
        database: 0
      cloud:
        nacos:
          discovery:
            server-addr: ${NACOS_SERVER}
            namespace: ${NACOS_NAMESPACE}
    management:
      endpoints:
        web:
          exposure:
            include: health,info,metrics,prometheus
      endpoint:
        health:
          show-details: always
```

#### 5.2.2 密钥管理

```yaml
# Secret配置
apiVersion: v1
kind: Secret
metadata:
  name: user-service-secret
  namespace: multishop
type: Opaque
data:
  mysql.username: <base64-encoded-username>
  mysql.password: <base64-encoded-password>
  redis.password: <base64-encoded-password>
  jwt.secret: <base64-encoded-jwt-secret>
```

### 5.3 自动化部署

#### 5.3.1 CI/CD流水线

```yaml
# GitLab CI配置
stages:
  - build
  - test
  - package
  - deploy

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  DOCKER_REGISTRY: "registry.multishop.com"

build:
  stage: build
  image: maven:3.8.4-openjdk-17
  script:
    - mvn clean compile
  cache:
    paths:
      - .m2/repository/

test:
  stage: test
  image: maven:3.8.4-openjdk-17
  script:
    - mvn test
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    reports:
      junit:
        - target/surefire-reports/TEST-*.xml
      coverage_report:
        coverage_format: jacoco
        path: target/site/jacoco/jacoco.xml

package:
  stage: package
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - mvn clean package -DskipTests
    - docker build -t $DOCKER_REGISTRY/msc-user-core:$CI_COMMIT_SHA .
    - docker push $DOCKER_REGISTRY/msc-user-core:$CI_COMMIT_SHA
  only:
    - main
    - develop

deploy:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl set image deployment/msc-user-core msc-user-core=$DOCKER_REGISTRY/msc-user-core:$CI_COMMIT_SHA -n multishop
    - kubectl rollout status deployment/msc-user-core -n multishop
  only:
    - main
```

## 六、性能优化设计

### 6.1 数据库优化

#### 6.1.1 索引优化策略

```sql
-- 用户表索引优化
-- 1. 登录查询优化
CREATE INDEX idx_user_login ON user(phone, password);
CREATE INDEX idx_user_email_login ON user(email, password);

-- 2. 状态查询优化
CREATE INDEX idx_user_status ON user(status, create_time);

-- 3. 会员等级查询优化
CREATE INDEX idx_user_member_level ON user(member_level, total_amount);

-- 4. 复合索引优化
CREATE INDEX idx_user_composite ON user(status, member_level, create_time);
```

#### 6.1.2 查询优化

```java
// 分页查询优化
@Repository
public class UserRepository {
    
    // 使用游标分页避免深分页问题
    public List<User> findUsersByLastId(Long lastId, int pageSize) {
        return jdbcTemplate.query(
            "SELECT * FROM user WHERE id > ? ORDER BY id LIMIT ?",
            new Object[]{lastId, pageSize},
            new UserRowMapper()
        );
    }
    
    // 批量查询优化
    public List<User> findUsersByIds(List<Long> userIds) {
        String sql = "SELECT * FROM user WHERE id IN (" + 
                    userIds.stream().map(id -> "?").collect(Collectors.joining(",")) + ")";
        return jdbcTemplate.query(sql, userIds.toArray(), new UserRowMapper());
    }
}
```

### 6.2 缓存优化

#### 6.2.1 缓存预热

```java
@Component
public class CacheWarmupService {
    
    @EventListener(ApplicationReadyEvent.class)
    public void warmupCache() {
        // 预热热点用户数据
        List<Long> hotUserIds = getHotUserIds();
        hotUserIds.parallelStream().forEach(userId -> {
            User user = userService.getUserById(userId);
            cacheManager.getCache("user").put(userId, user);
        });
    }
    
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void refreshCache() {
        // 刷新即将过期的缓存
        refreshExpiringCache();
    }
}
```

#### 6.2.2 缓存穿透防护

```java
@Service
public class UserService {
    
    @Cacheable(value = "user", key = "#userId", unless = "#result == null")
    public User getUserById(Long userId) {
        // 布隆过滤器检查
        if (!bloomFilter.mightContain(userId)) {
            return null;
        }
        
        User user = userRepository.findById(userId);
        if (user == null) {
            // 缓存空值，防止缓存穿透
            cacheManager.getCache("user").put(userId, new NullUser());
        }
        return user;
    }
}
```

### 6.3 并发优化

#### 6.3.1 分布式锁

```java
@Service
public class UserRegistrationService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean registerUser(UserRegisterRequest request) {
        String lockKey = "user:register:" + request.getPhone();
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 获取分布式锁
            Boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(30));
            
            if (!acquired) {
                throw new BusinessException("注册请求过于频繁，请稍后重试");
            }
            
            // 执行注册逻辑
            return doRegisterUser(request);
            
        } finally {
            // 释放锁
            releaseLock(lockKey, lockValue);
        }
    }
}
```

#### 6.3.2 异步处理

```java
@Service
public class UserEventHandler {
    
    @Async("userTaskExecutor")
    @EventListener
    public void handleUserRegistered(UserRegisteredEvent event) {
        // 异步处理用户注册后的操作
        // 1. 发送欢迎邮件
        emailService.sendWelcomeEmail(event.getUserId());
        
        // 2. 初始化用户积分
        pointsService.initUserPoints(event.getUserId());
        
        // 3. 记录用户行为日志
        userBehaviorService.recordRegistration(event.getUserId());
    }
    
    @Bean("userTaskExecutor")
    public TaskExecutor userTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("user-async-");
        executor.initialize();
        return executor;
    }
}
```

## 七、容灾与备份设计

### 7.1 高可用设计

#### 7.1.1 服务容错

```java
// 熔断器配置
@Component
public class UserServiceFallback implements UserService {
    
    @Override
    public User getUserById(Long userId) {
        // 降级处理：返回缓存数据或默认数据
        User cachedUser = getCachedUser(userId);
        if (cachedUser != null) {
            return cachedUser;
        }
        
        // 返回默认用户信息
        return createDefaultUser(userId);
    }
}

// 重试机制
@Retryable(value = {DataAccessException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
public User getUserFromDatabase(Long userId) {
    return userRepository.findById(userId);
}
```

#### 7.1.2 数据备份策略

```bash
#!/bin/bash
# 数据库备份脚本

# 配置参数
DB_HOST="mysql-master"
DB_USER="backup_user"
DB_PASSWORD="backup_password"
DB_NAME="multishop_user"
BACKUP_DIR="/data/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 全量备份
mysqldump -h$DB_HOST -u$DB_USER -p$DB_PASSWORD \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  $DB_NAME > $BACKUP_DIR/user_full_backup_$DATE.sql

# 压缩备份文件
gzip $BACKUP_DIR/user_full_backup_$DATE.sql

# 删除7天前的备份文件
find $BACKUP_DIR -name "user_full_backup_*.sql.gz" -mtime +7 -delete

# 上传到云存储
aws s3 cp $BACKUP_DIR/user_full_backup_$DATE.sql.gz s3://multishop-backup/mysql/
```

### 7.2 监控告警

#### 7.2.1 监控指标配置

```yaml
# Prometheus监控配置
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'msc-user-core'
    static_configs:
      - targets: ['msc-user-core:8080']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 30s

rule_files:
  - "user_service_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

#### 7.2.2 告警规则

```yaml
# user_service_rules.yml
groups:
- name: user_service_alerts
  rules:
  - alert: UserServiceHighErrorRate
    expr: rate(http_requests_total{job="msc-user-core",status=~"5.."}[5m]) > 0.01
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "用户服务错误率过高"
      description: "用户服务在过去5分钟内错误率超过1%"

  - alert: UserServiceHighResponseTime
    expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{job="msc-user-core"}[5m])) > 2
    for: 3m
    labels:
      severity: warning
    annotations:
      summary: "用户服务响应时间过长"
      description: "用户服务95%请求响应时间超过2秒"

  - alert: UserDatabaseConnectionHigh
    expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections > 0.8
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "用户数据库连接数过高"
      description: "用户数据库连接数超过最大连接数的80%"
```

---

*本文档为用户模块系统架构设计规格说明书，涵盖了架构设计、技术选型、部署方案等关键内容。*